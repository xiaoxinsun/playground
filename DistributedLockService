package com.workflow.limit;

import io.agroal.api.AgroalDataSource;
import io.quarkus.logging.Log;
import jakarta.enterprise.context.ApplicationScoped; // Use ApplicationScoped
import jakarta.inject.Inject;

import java.sql.Connection;
import java.sql.PreparedStatement; // Import PreparedStatement
import java.sql.ResultSet;
// import java.sql.Statement; // No longer needed
import java.util.concurrent.Callable;
import java.util.concurrent.TimeoutException;

/**
 * The production implementation of the LockService using PostgreSQL Advisory Locks.
 */
@ApplicationScoped // This is the default implementation
public class PostgresLockService implements LockService {

    @Inject
    AgroalDataSource dataSource;

    /**
     * Tries to acquire a lock for a given key and execute a function.
     * The lock is automatically released when the function completes or throws an error.
     *
     * @param lockKey The unique key to lock (e.g., customerId)
     * @param protectedTask The Callable (function) to execute while holding the lock.
     * @return The result from the protectedTask.
     * @throws Exception If the protectedTask throws an exception.
     * @throws TimeoutException If the lock cannot be acquired.
     */
    @Override
    public <T> T tryWithLock(String lockKey, Callable<T> protectedTask) throws Exception {
        // Advisory locks use a 64-bit integer. We can get a stable one
        // from the string's hashcode. We'll use the hashcode directly.
        // This avoids the SonarQube bug: Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE
        int lockId = lockKey.hashCode();

        // We MUST use a raw JDBC connection because advisory locks are
        // session-scoped. The lock is held as long as this connection is open
        // and is automatically released when the connection is closed by the try-with-resources.
        try (Connection conn = dataSource.getConnection()) {

            Log.infof("Attempting to acquire PG lock for key '%s' (hash: %d)", lockKey, lockId);

            // 1. Try to acquire the lock (non-blocking)
            // We use PreparedStatement to prevent SQL injection vulnerabilities.
            try (PreparedStatement lockStmt = conn.prepareStatement("SELECT pg_try_advisory_lock(?)")) {
                lockStmt.setInt(1, lockId);

                try (ResultSet rs = lockStmt.executeQuery()) {
                    if (rs.next() && rs.getBoolean(1)) {
                        // 2. Lock Acquired!
                        Log.infof("PG Lock acquired for key '%s'", lockKey);
                        try {
                            // Execute the protected code (e.g., your GET and UPDATE API calls)
                            return protectedTask.call();
                        } finally {
                            // 3. Release the lock.
                            // Use a PreparedStatement here as well for good practice.
                            try (PreparedStatement unlockStmt = conn.prepareStatement("SELECT pg_advisory_unlock(?)")) {
                                unlockStmt.setInt(1, lockId);
                                unlockStmt.execute();
                                Log.infof("PG Lock released for key '%s'", lockKey);
                            }
                        }
                    } else {
                        // 4. Lock Not Acquired
                        // Someone else is processing this customer. Fail fast.
                        Log.warnf("Failed to acquire PG lock for key '%s'. Resource is busy.", lockKey);
                        throw new TimeoutException("Could not acquire lock for " + lockKey + ". The account is being updated by another process.");
                    }
                }
            }
        }
    }
}
