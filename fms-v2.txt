// Save this entire file as WorkflowResource.java

import org.squirrelframework.foundation.fsm.Condition;
import org.squirrelframework.foundation.fsm.StateMachineBuilderFactory;
import org.squirrelframework.foundation.fsm.UntypedStateMachine;
import org.squirrelframework.foundation.fsm.UntypedStateMachineBuilder;
import org.squirrelframework.foundation.fsm.annotation.StateMachineParameters;
import org.squirrelframework.foundation.fsm.impl.AbstractStateMachine;

import javax.annotation.PostConstruct;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Random;
import java.util.Set;

//
// --- 1. JAX-RS Endpoint Class ---
//
@Path("/workflow")
@Produces(MediaType.APPLICATION_JSON)
public class WorkflowResource {

    @Inject
    MyWorkflowEngine engine;

    /**
     * Starts a new "order" workflow.
     * This is the "first request" which also processes the first automatic step.
     */
    @POST
    @Path("/start")
    public WorkflowStepResponse startWorkflow() {
        // 1. Get a new FSM instance and fire the START event
        UntypedStateMachine fsm = engine.startWorkflowInstance("order");
        fsm.fire(OrderFlowEvent.START_FLOW, null);
        
        // The FSM is now at the 'CREATE_ORDER' state
        OrderFlowState currentState = (OrderFlowState) fsm.getCurrentState();
        System.out.println("[API] Workflow started. Initial state: " + currentState);

        // 2. Perform the business logic that was in the 'onEntry' listener
        // This is the logic for the 'CREATE_ORDER' node
        System.out.println("[API-Logic] Processing 'CREATE_ORDER' logic...");
        boolean isSuccess = new Random().nextBoolean(); // Simulating logic
        String action = isSuccess ? "success" : "failure";
        System.out.println("[API-Logic] 'CREATE_ORDER' result: " + action);

        // 3. Ask the engine for the *next* state based on this logic
        WorkflowStepResponse response = engine.getNextState(currentState, action);

        System.out.println("[API] 'CREATE_ORDER' auto-completed. New state: " + response.getNewState());
        return response;
    }

    /**
     * Completes the current active node and moves to the next.
     * This is the "subsequent api call".
     */
    @POST
    @Path("/step")
    public WorkflowStepResponse stepWorkflow(WorkflowStepRequest request) {
        System.out.println("[API] Received step request. Current: " + request.getCurrentState() + ", Action: " + request.getAction());
        
        // 1. Ask the engine for the next state
        WorkflowStepResponse response = engine.getNextState(request.getCurrentState(), request.getAction());

        System.out.println("[API] Step complete. New state: " + response.getNewState());
        return response;
    }
}

//
// --- 2. Workflow Engine (Singleton) ---
//
@ApplicationScoped
class MyWorkflowEngine {

    private final Map<String, UntypedStateMachineBuilder> workflowBuilders = new HashMap<>();
    private final Set<OrderFlowState> terminalStates = new HashSet<>();

    @PostConstruct
    public void defineWorkflows() {
        defineOrderWorkflow();
    }

    /**
     * Creates a new state machine instance starting at its initial state.
     * Used by the 'start' endpoint.
     */
    public UntypedStateMachine startWorkflowInstance(String workflowId) {
        UntypedStateMachineBuilder builder = workflowBuilders.get(workflowId);
        if (builder == null) {
            throw new NoSuchElementException("No workflow definition found for ID: " + workflowId);
        }
        Object initialState = builder.getInitialState();
        return builder.newStateMachine(initialState);
    }

    /**
     * This is the core "stateless" function.
     * It creates a temporary FSM, sets its state, fires the event,
     * and returns the resulting state.
     */
    public WorkflowStepResponse getNextState(OrderFlowState currentState, String action) {
        UntypedStateMachineBuilder builder = workflowBuilders.get("order");
        if (builder == null) {
            throw new NoSuchElementException("Order workflow definition not found.");
        }

        // 1. Create a new FSM instance *at the specified current state*
        UntypedStateMachine fsm = builder.newStateMachine(currentState);

        // 2. Fire the "COMPLETE" event with the given action
        fsm.fire(OrderFlowEvent.COMPLETE, new TaskContext(action));

        // 3. Get the new state
        OrderFlowState newState = (OrderFlowState) fsm.getCurrentState();

        // 4. Check if this new state is a terminal state
        boolean isTerminated = terminalStates.contains(newState);

        return new WorkflowStepResponse(newState, isTerminated);
    }

    // --- Workflow Definition: Order Flow ---
    private void defineOrderWorkflow() {
        UntypedStateMachineBuilder builder = StateMachineBuilderFactory.create(
                OrderFlowStateMachine.class, OrderFlowState.class, OrderFlowEvent.class, TaskContext.class);

        // Req 1 -> 2: Start -> Create Order
        builder.externalTransition().from(OrderFlowState.START).to(OrderFlowState.CREATE_ORDER).on(OrderFlowEvent.START_FLOW);

        // Req 3: Conditional transition from Create Order
        builder.externalTransition().from(OrderFlowState.CREATE_ORDER).to(OrderFlowState.SETTLEMENT_MAKER).on(OrderFlowEvent.COMPLETE).when(ActionCondition.is("success"));
        builder.externalTransition().from(OrderFlowState.CREATE_ORDER).to(OrderFlowState.INVESTMENT_MAKER).on(OrderFlowEvent.COMPLETE).when(ActionCondition.is("failure"));

        // Req 4: Settlement Maker -> Settlement Checker
        builder.externalTransition().from(OrderFlowState.SETTLEMENT_MAKER).to(OrderFlowState.SETTLEMENT_CHECKER).on(OrderFlowEvent.COMPLETE).when(ActionCondition.is("submit"));

        // Req 5: Settlement Checker transitions
        builder.externalTransition().from(OrderFlowState.SETTLEMENT_CHECKER).to(OrderFlowState.END_APPROVED).on(OrderFlowEvent.COMPLETE).when(ActionCondition.is("approve"));
        builder.externalTransition().from(OrderFlowState.SETTLEMENT_CHECKER).to(OrderFlowState.END_REJECTED).on(OrderFlowEvent.COMPLETE).when(ActionCondition.is("reject"));
        builder.externalTransition().from(OrderFlowState.SETTLEMENT_CHECKER).to(OrderFlowState.SETTLEMENT_MAKER).on(OrderFlowEvent.COMPLETE).when(ActionCondition.is("send_back"));

        // Req 6: Investment Maker -> Investment Checker
        builder.externalTransition().from(OrderFlowState.INVESTMENT_MAKER).to(OrderFlowState.INVESTMENT_CHECKER).on(OrderFlowEvent.COMPLETE).when(ActionCondition.is("submit"));
        
        // Req 7: Investment Checker transitions
        builder.externalTransition().from(OrderFlowState.INVESTMENT_CHECKER).to(OrderFlowState.SETTLEMENT_MAKER).on(OrderFlowEvent.COMPLETE).when(ActionCondition.is("approve"));
        builder.externalTransition().from(OrderFlowState.INVESTMENT_CHECKER).to(OrderFlowState.END_REJECTED).on(OrderFlowEvent.COMPLETE).when(ActionCondition.is("reject"));
        builder.externalTransition().from(OrderFlowState.INVESTMENT_CHECKER).to(OrderFlowState.INVESTMENT_MAKER).on(OrderFlowEvent.COMPLETE).when(ActionCondition.is("send_back"));

        // **NOTE: We have removed ALL 'onEntry().callMethod()' lines **
        // The FSM is now "pure".

        // Define and store terminal states
        builder.terminateState(OrderFlowState.END_APPROVED);
        builder.terminateState(OrderFlowState.END_REJECTED);
        
        terminalStates.add(OrderFlowState.END_APPROVED);
        terminalStates.add(OrderFlowState.END_REJECTED);

        // Store this new definition
        workflowBuilders.put("order", builder);
    }
}

//
// --- 3. DTOs (Data Transfer Objects) ---
//

/**
 * The JSON request body for the /step endpoint
 */
class WorkflowStepRequest {
    private OrderFlowState currentState;
    private String action;

    // Getters and Setters
    public OrderFlowState getCurrentState() { return currentState; }
    public void setCurrentState(OrderFlowState currentState) { this.currentState = currentState; }
    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }
}

/**
 * The JSON response from all workflow endpoints
 */
class WorkflowStepResponse {
    private OrderFlowState newState;
    private boolean isTerminated;

    public WorkflowStepResponse(OrderFlowState newState, boolean isTerminated) {
        this.newState = newState;
        this.isTerminated = isTerminated;
    }

    // Getters
    public OrderFlowState getNewState() { return newState; }
    public boolean isTerminated() { return isTerminated; }
}


//
// --- 4. Helper Classes and Enums ---
//

/**
 * The "completion argument" object passed when firing an event.
 */
class TaskContext {
    private final String action;
    public TaskContext(String action) { this.action = action; }
    public String getAction() { return action; }
    // equals() and hashCode() are good practice
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TaskContext that = (TaskContext) o;
        return Objects.equals(action, that.action);
    }
    @Override
    public int hashCode() { return Objects.hash(action); }
}

/**
 * The "Guard" condition that checks the action in the TaskContext.
 */
class ActionCondition implements Condition<TaskContext> {
    private final String expectedAction;
    private ActionCondition(String expectedAction) { this.expectedAction = expectedAction; }
    public static ActionCondition is(String action) { return new ActionCondition(action); }
    @Override
    public boolean isSatisfied(TaskContext context) {
        return context != null && expectedAction.equals(context.getAction());
    }
    @Override
    public String name() { return "ActionIs_" + expectedAction; }
}

// --- Order Workflow: State Machine Class & Enums ---

/**
 * This class is now empty. It serves only as a type parameter
 * for the StateMachineBuilder to enforce type safety.
 */
@StateMachineParameters(stateType = OrderFlowState.class, eventType = OrderFlowEvent.class, contextType = TaskContext.class)
class OrderFlowStateMachine extends AbstractStateMachine<OrderFlowStateMachine, OrderFlowState, OrderFlowEvent, TaskContext> {
    // No 'onEntry' logic lives here anymore!
}

enum OrderFlowState {
    START,
    CREATE_ORDER,
    SETTLEMENT_MAKER,
    SETTLEMENT_CHECKER,
    INVESTMENT_MAKER,
    INVESTMENT_CHECKER,
    END_APPROVED,
    END_REJECTED
}

enum OrderFlowEvent {
    START_FLOW,
    COMPLETE // The only event needed for state-to-state transitions
}
